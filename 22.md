1. **增强核心逻辑 (`useGame.ts`)** ：加入推进幕次、重置状态等新功能。
2. **升级UI界面 (`GalgameInterface.vue`)** ：添加新按钮和逻辑来处理幕次推进和新一轮的独白与问答。

---

### 第1步: 升级游戏状态管理器 (`useGame.ts`)

这个文件需要添加处理幕次推进和在进入新幕次时重置部分状态的功能。

请**修改**您现有的 `src/composables/useGame.ts` 文件。主要改动是增加 `questionCount`、`advanceAct` 函数，并调整 `startGame` 和 `askQuestion` 以支持多幕次。

**TypeScript**

```
// src/composables/useGame.ts

import { ref, readonly, computed } from 'vue'
import axios from 'axios'

// --- 数据结构定义 (不变) ---
export interface Character {
  id: string;
  displayName: string;
  isPlayer: boolean;
  model?: string;
}

export type HistoryEntry =
  | { type: 'monologue'; characterId: string; content: string }
  | { type: 'question'; questionerId: string; targetCharacterId: string; content: string }
  | { type: 'answer'; characterId: string; content: string }
  | { type: 'system'; content: string };

export type GamePhase = 'initializing' | 'monologue' | 'qna' | 'final_choice' | 'completed';

const API_BASE_URL = 'http://127.0.0.1:8000/api/v1/langchain-game'

export const getDisplayName = (id: string, characters: ReadonlyMap<string, Character> | Map<string, Character>) => {
  if (id === 'system') return '系统提示';
  return characters.get(id)?.displayName || id;
};

export function useGame() {
  // 基础状态
  const sessionId = ref<string | null>(null)
  const characters = ref<Map<string, Character>>(new Map())
  const playerCharacterId = ref<string | null>(null)
  const gamePhase = ref<GamePhase>('initializing')
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const currentAct = ref(1) // 新增：当前幕次
  const questionCount = ref(0) // 新增：当前幕次的提问计数

  // 独白相关状态
  const monologueProgress = ref({ current: 0, total: 0 })
  const interactionHistory = ref<HistoryEntry[]>([])

  // 独白队列系统
  interface MonologueEntry {
    characterId: string;
    sentence: string;
  }
  const unifiedMonologueQueue = ref<MonologueEntry[]>([])
  const currentSentenceIndex = ref(0)

  /**
   * (不变) 根据后端数据构建角色映射表
   */
  const setupCharacters = (allCharacters: string[], assignedPlayerRole: string) => {
    const newCharacters = new Map<string, Character>()
    playerCharacterId.value = assignedPlayerRole
  
    const aiModels = ['qwen', 'openai', 'deepseek', 'kimi']
    let aiModelIndex = 0

    allCharacters.forEach(charId => {
      const isPlayer = charId === assignedPlayerRole
      let model = undefined;
      let displayName = charId;

      if (!isPlayer) {
          model = aiModels[aiModelIndex % aiModels.length];
          displayName = `${charId} (${model})`
          aiModelIndex++;
      } else {
          displayName = `${charId} (我)`
      }

      newCharacters.set(charId, { id: charId, displayName, isPlayer, model })
    })
    characters.value = newCharacters
    console.log('[Game] 角色信息初始化完成:', characters.value)
  }

  const startGame = async (scriptId: string, _humanPlayerId: string) => {
    isLoading.value = true
    error.value = null
    gamePhase.value = 'initializing'
    interactionHistory.value = [] // 清空历史记录
  
    try {
      const startResponse = await axios.post(`${API_BASE_URL}/start`, {
        script_id: scriptId,
        user_id: null
      })

      if (!startResponse.data.success) throw new Error(startResponse.data.message || '创建游戏失败')

      const sessionData = startResponse.data.data
      sessionId.value = sessionData.session_id
    
      const availableRoles = sessionData.available_human_characters;
      const chosenCharacterId = availableRoles[0]; 

      setupCharacters(availableRoles, chosenCharacterId);

      interactionHistory.value.push({
        type: 'system',
        content: `第一幕开始！你被分配为角色：${chosenCharacterId}`
      })

      gamePhase.value = 'monologue'
      await fetchAndProcessAllMonologues(availableRoles)
    
    } catch (e: any) {
      error.value = e.message || '无法连接到服务器'
    } finally {
      isLoading.value = false
    }
  };

  /**
   * (不变) 获取并重组所有独白
   */
  const fetchAndProcessAllMonologues = async (availableRoles: string[]) => {
    if (!sessionId.value) return;
    isLoading.value = true
    const characterSentencesMap: Map<string, string[]> = new Map()

    const monologuePromises = availableRoles.map(async (characterId) => {
      try {
        const response = await axios.post(
          `${API_BASE_URL}/session/${sessionId.value}/action`,
          { action_type: 'monologue', character_id: characterId }
        )
        if (response.data.success && response.data.data.monologue_sentences) {
          const sentences = response.data.data.monologue_sentences
            .flatMap((p: string) => p.split('\n').filter(s => s.trim() !== ''))
          characterSentencesMap.set(characterId, sentences)
        }
      } catch (e) {
        console.error(`[Game] 获取角色 [${characterId}] 独白失败:`, e)
      }
    })

    await Promise.all(monologuePromises)

    const newQueue: MonologueEntry[] = []
    const maxSentences = 5 

    for (let i = 0; i < maxSentences; i++) {
      for (const charId of availableRoles) {
        const sentences = characterSentencesMap.get(charId)
        if (sentences && i < sentences.length) {
          newQueue.push({ characterId: charId, sentence: sentences[i] })
        }
      }
    }

    unifiedMonologueQueue.value = newQueue
    currentSentenceIndex.value = 0
    monologueProgress.value = { current: 0, total: newQueue.length }
    isLoading.value = false
  }

  /**
   * (不变) 推进独白
   */
  const advanceMonologue = (): MonologueEntry | null => {
    if (currentSentenceIndex.value < unifiedMonologueQueue.value.length) {
      const nextEntry = unifiedMonologueQueue.value[currentSentenceIndex.value]
      currentSentenceIndex.value++
      monologueProgress.value.current = currentSentenceIndex.value
      return nextEntry
    }
    gamePhase.value = 'qna'
    questionCount.value = 0 // 进入QNA时重置提问计数
    return null
  }

  /**
   * (修改) 向指定角色提问，并增加计数
   */
  const askQuestion = async (targetCharacterId: string, question: string) => {
    if (!sessionId.value || !playerCharacterId.value) return;
    isLoading.value = true
    error.value = null
  
    interactionHistory.value.push({
      type: 'question',
      questionerId: playerCharacterId.value,
      targetCharacterId: targetCharacterId,
      content: question
    })

    try {
      const response = await axios.post(
        `${API_BASE_URL}/session/${sessionId.value}/action`,
        {
          action_type: 'qna',
          character_id: targetCharacterId,
          question: question,
          questioner_id: playerCharacterId.value
        }
      )

      if (response.data.success) {
        interactionHistory.value.push({
          type: 'answer',
          characterId: targetCharacterId,
          content: response.data.data.answer
        })
        questionCount.value++ // 提问成功后计数加一
      } else {
        throw new Error(response.data.error || '提问失败')
      }
    } catch (e: any) {
      error.value = e.message || '提问请求失败'
    } finally {
      isLoading.value = false
    }
  }
  
  /**
   * (新增) 推进到下一幕
   */
  const advanceAct = async () => {
    if (!sessionId.value) return;
    isLoading.value = true
    try {
      // 1. 调用后端API推进幕次
      const response = await axios.post(`${API_BASE_URL}/session/${sessionId.value}/action`, {
        action_type: 'advance_act'
      });

      if (!response.data.success) {
        throw new Error('推进幕次失败');
      }
    
      const { new_act, current_phase } = response.data.data;
      currentAct.value = new_act;
      gamePhase.value = current_phase;

      interactionHistory.value.push({
        type: 'system',
        content: `--- 第 ${new_act} 幕开始 ---`
      });

      // 2. 重新获取新一幕的独白
      if (current_phase === 'monologue' && characters.value.size > 0) {
        const characterIds = Array.from(characters.value.keys());
        await fetchAndProcessAllMonologues(characterIds);
      }
    } catch (e: any) {
      error.value = e.message;
    } finally {
      isLoading.value = false;
    }
  };

  return {
    // ... (原有返回不变)
    sessionId: readonly(sessionId),
    characters: readonly(characters),
    playerCharacterId: readonly(playerCharacterId),
    gamePhase: readonly(gamePhase),
    isLoading: readonly(isLoading),
    error: readonly(error),
    monologueProgress: readonly(monologueProgress),
    interactionHistory: readonly(interactionHistory),
    unifiedMonologueQueue: readonly(unifiedMonologueQueue),
    currentSentenceIndex: readonly(currentSentenceIndex),
    interrogationTargets: computed(() =>
        Array.from(characters.value.values()).filter(c => !c.isPlayer)
    ),
  
    // 新增返回
    currentAct: readonly(currentAct),
    questionCount: readonly(questionCount),

    // 方法
    startGame,
    advanceMonologue,
    askQuestion,
    advanceAct, // 新增方法
    addHistoryEntry: (entry: HistoryEntry) => interactionHistory.value.push(entry)
  }
}
```

---

### 第2步: 升级UI界面 (`GalgameInterface.vue`)

界面上需要增加一个“进入下一幕”的按钮，并且在提问区显示当前的提问次数。

以下供你参考：

**代码段**

```
<template>
  <div class="galgame-main-container">
    <div class="main-game-panel">
        </div>

    <div class="resize-divider"></div>

    <div class="interrogation-sidebar">
      <div class="sidebar-section history-section">
        <h3 class="section-title">询问历史</h3>
        <div class="history-log" ref="historyLogRef">
          </div>
      </div>
  
      <div class="sidebar-section ask-section">
        <div class="section-header">
          <h3 class="section-title">提问 (第 {{ currentAct }}幕)</h3>
          <div class="qna-controls">
            <span class="question-counter">提问: {{ questionCount }} / 12</span>
            <button
              @click="handleAdvanceAct"
              :disabled="isLoading || gamePhase !== 'qna'"
              class="next-act-button"
            >
              进入下一幕
            </button>
          </div>
        </div>

        <div class="character-tabs">
          </div>
        <textarea
          v-model="customQuestion"
          placeholder="在此输入你对角色的提问..."
          class="custom-question-textarea"
          rows="4"
          :disabled="gamePhase !== 'qna' || isLoading"
        ></textarea>
        <button
          @click="handleAskQuestion"
          :disabled="!customQuestion.trim() || !selectedCharacterId || isLoading || gamePhase !== 'qna'"
          class="ask-question-button"
        >
          发送问题
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, nextTick, onMounted } from 'vue';
import { useRoute } from 'vue-router';
// 引入最新的 useGame
import { useGame, getDisplayName } from '@/composables/useGame';

// --- 状态管理 ---
const route = useRoute();
const {
  isLoading, gamePhase, characters, interactionHistory,
  interrogationTargets,
  currentAct, // 新增
  questionCount, // 新增
  startGame, advanceMonologue, askQuestion, advanceAct // 新增 advanceAct
} = useGame();

// --- 本地组件状态 ---
const selectedCharacterId = ref<string | null>(null);
const customQuestion = ref('');
const historyLogRef = ref<HTMLElement | null>(null);
const activeCharacter = ref<any>(null); // 假设用于显示角色信息

// --- 方法 ---
const handleContinue = () => {
  const entry = advanceMonologue();
  if (entry) {
    // 假设你有逻辑来更新 activeCharacter
    // activeCharacter.value = ...
  }
};

const handleAskQuestion = async () => {
  if (!customQuestion.value.trim() || !selectedCharacterId.value) return;
  await askQuestion(selectedCharacterId.value, customQuestion.value);
  customQuestion.value = '';

  // 检查是否达到提问上限
  if (questionCount.value >= 12) {
    // 可以在这里自动触发进入下一幕，或者只是提示用户
    console.log("已达到本幕提问上限，请点击'进入下一幕'。");
    // 可选：自动推进
    // handleAdvanceAct(); 
  }
};

// 新增：处理进入下一幕的点击事件
const handleAdvanceAct = async () => {
  await advanceAct();
  // 推进幕次后，第一个独白会自动开始（如果存在）
  handleContinue();
};

// --- 生命周期与监听 ---
onMounted(() => {
  startGame(route.params.scriptId as string, '神探李');
});

watch(interactionHistory, () => {
  nextTick(() => {
    const logEl = historyLogRef.value;
    if (logEl) {
      logEl.scrollTop = logEl.scrollHeight;
    }
  });
}, { deep: true });

// 监听提问数，达到12次时可以给出提示
watch(questionCount, (newCount) => {
    if (newCount === 12) {
        // 在历史记录中添加系统提示
        // addHistoryEntry({ type: 'system', content: '本幕提问已达上限，请点击“进入下一幕”继续。' });
    }
});
</script>

<style scoped>
/* ... (大部分样式保持不变) ... */

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.qna-controls {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.question-counter {
  font-size: 0.8rem;
  color: var(--text-secondary);
  background: #1a202c;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
}

.next-act-button {
  padding: 0.4rem 0.8rem;
  background: #c0392b; /* 使用醒目的颜色 */
  border: none;
  color: white;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.8rem;
  font-weight: 600;
  transition: all 0.2s;
}
.next-act-button:hover:not(:disabled) {
  background: #e74c3c;
  transform: translateY(-1px);
}
.next-act-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ... (其他样式 .ask-section, .character-tabs 等保持不变) ... */
</style>
```

### **代码解释与最终效果**

1. **`useGame.ts` 的核心增强** ：

* 新增了 `currentAct` 和 `questionCount` 两个状态，用于追踪游戏进程。
* `askQuestion` 函数现在会在每次成功提问后将 `questionCount` 加一。
* 全新的 `advanceAct` 函数负责调用后端 `/action` 接口（`action_type: 'advance_act'`），并在成功后重置游戏阶段，然后调用 `fetchAndProcessAllMonologues` 来加载第二幕的独白。

1. **`GalgameInterface.vue` 的UI升级** ：

* 在“提问”区域的标题旁边，我们增加了一个**提问计数器** (`{{ questionCount }} / 12`) 和一个红色的**“进入下一幕”**按钮。
* `handleAskQuestion` 函数现在会检查提问次数，您甚至可以配置在达到12次后自动调用 `handleAdvanceAct`。
* `handleAdvanceAct` 函数被绑定到新按钮上，点击后会触发 `useGame.ts` 中的 `advanceAct` 逻辑，无缝衔接进入第二幕。

现在，您的游戏已经具备了完整的多幕次流程。当第一幕的12次问答完成后，玩家可以点击按钮进入第二幕，系统会自动加载并开始第二幕的独白，随后进入第二轮的Q&A，完美匹配了您的设计需求。
