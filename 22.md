我们将实现以下三大核心功能：

1. **前端自动角色分配** : 游戏开始时，前端将自动为您分配一个角色（标记为“我”），并为其他AI角色标记上对应的模型名称。
2. **智能提问对象过滤** : 在提问环节，角色选择列表中将只显示除您之外的其他AI角色。
3. **全流程日志式历史记录** : 侧边栏的“询问历史”将像聊天记录一样，清晰地展示所有角色的独白、您的提问以及角色的回答。

### 第1步: 更新游戏状态管理器 (`useGame.ts`)

这个文件将进行微调，以支持更智能的角色分配和提问对象过滤。

请**修改**您现有的 `src/composables/useGame.ts` 文件。主要改动是在 `setupCharacters` 函数和新增一个 `interrogationTargets` 计算属性。

**TypeScript**

```
// src/composables/useGame.ts

import { ref, readonly, computed } from 'vue'
import axios from 'axios'

// --- 数据结构定义 (不变) ---
export interface Character {
  id: string;
  displayName: string;
  isPlayer: boolean;
  model?: string;
}

export type HistoryEntry = 
  | { type: 'monologue'; characterId: string; content: string }
  | { type: 'question'; questionerId: string; targetCharacterId: string; content: string }
  | { type: 'answer'; characterId: string; content: string }
  | { type: 'system'; content: string };

export type GamePhase = 'initializing' | 'monologue' | 'qna' | 'completed';

const API_BASE_URL = 'http://127.0.0.1:8000/api/v1/langchain-game'
// ...

// (修改) getDisplayName 函数现在需要传入 characters Map
export const getDisplayName = (id: string, characters: Map<string, Character>) => {
  if (id === 'system') return '系统提示';
  return characters.get(id)?.displayName || id;
};

export function useGame() {
  // ... ref 定义不变 ...
  const characters = ref<Map<string, Character>>(new Map())
  const playerCharacterId = ref<string | null>(null)
  
  /**
   * (修改) 根据后端数据构建角色映射表, 自动分配角色
   */
  const setupCharacters = (allCharacters: string[], assignedPlayerRole: string) => {
    const newCharacters = new Map<string, Character>()
    playerCharacterId.value = assignedPlayerRole
  
    // AI模型分配
    const aiModels = ['qwen', 'openai', 'deepseek', 'kimi']
    let aiModelIndex = 0

    allCharacters.forEach(charId => {
      const isPlayer = charId === assignedPlayerRole
      let model = undefined;
      let displayName = charId;

      if (!isPlayer) {
          model = aiModels[aiModelIndex % aiModels.length];
          displayName = `${charId} (${model})`
          aiModelIndex++;
      } else {
          displayName = `${charId} (我)`
      }

      newCharacters.set(charId, { id: charId, displayName, isPlayer, model })
    })
    characters.value = newCharacters
    console.log('[Game] 角色信息初始化完成:', characters.value)
  }

  const startGame = async (scriptId: string, humanPlayerId: string) => {
    // ...
    // (修改) 从返回的角色列表中自动选择第一个作为玩家角色
    const availableRoles = sessionData.available_human_characters;
    // 假设后端返回的列表就是完整的角色列表，我们自动选择第一个作为玩家
    const chosenCharacterId = availableRoles[0]; 

    // ...
    // 使用这个自动选择的角色来加入游戏和设置角色
    setupCharacters(availableRoles, chosenCharacterId);
    // ...
  };

  // ... 其他函数 (advanceMonologue, askQuestion等) 保持不变 ...
  
  return {
    // ...
    // (新增) 导出可审讯的角色列表 (已过滤掉玩家自己)
    interrogationTargets: computed(() => 
        Array.from(characters.value.values()).filter(c => !c.isPlayer)
    ),
    // ...
  }
}
```

### 第2步: 最终版UI界面 (`GalgameInterface.vue`)

这是本次修改的重点。我们将彻底更新侧边栏的模板和样式，以精确匹配您的新设计图，并绑定所有新逻辑。

请**完全替换**您的 `src/components/GalgameInterface.vue` 文件的所有内容：

**代码段**

```
<template>
  <div class="galgame-main-container">
    <div class="main-game-panel">
      </div>

    <div class="resize-divider"></div>

    <div class="interrogation-sidebar">
    
      <div class="sidebar-section history-section">
        <h3 class="section-title">询问历史</h3>
        <div class="history-log" ref="historyLogRef">
          <div v-if="interactionHistory.length === 0" class="history-placeholder">
            还没有任何记录...
          </div>
          <div v-for="(entry, index) in interactionHistory" :key="index" :class="['history-entry', `entry-${entry.type}`]">
            <div v-if="entry.type === 'system'" class="system-message">{{ entry.content }}</div>
            <div v-else-if="entry.type === 'monologue'">
              <span class="history-speaker">{{ getDisplayName(entry.characterId, characters) }}: </span>
              <span class="history-content">{{ entry.content }}</span>
            </div>
            <div v-else-if="entry.type === 'question'">
              <span class="history-speaker player">{{ getDisplayName(entry.questionerId, characters) }}</span>
              <span> 对 </span>
              <span class="history-speaker">{{ getDisplayName(entry.targetCharacterId, characters) }}</span>
              <span> 说: </span>
              <span class="history-content question">"{{ entry.content }}"</span>
            </div>
            <div v-else-if="entry.type === 'answer'">
              <span class="history-speaker">{{ getDisplayName(entry.characterId, characters) }}: </span>
              <span class="history-content answer">{{ entry.content }}</span>
            </div>
          </div>
        </div>
      </div>
    
      <div class="sidebar-section ask-section">
        <h3 class="section-title">提问</h3>
        <div class="character-tabs">
          <button
            v-for="char in interrogationTargets"
            :key="char.id"
            @click="selectedCharacterId = char.id"
            :class="['tab-item', { active: selectedCharacterId === char.id }]"
            :disabled="gamePhase !== 'qna'"
          >
            {{ char.id }} </button>
        </div>
        <textarea
          v-model="customQuestion"
          placeholder="在此输入你对角色的提问..."
          class="custom-question-textarea"
          rows="4"
          :disabled="gamePhase !== 'qna' || isLoading"
        ></textarea>
        <button
          @click="handleAskQuestion"
          :disabled="!customQuestion.trim() || !selectedCharacterId || isLoading || gamePhase !== 'qna'"
          class="ask-question-button"
        >
          发送问题
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, nextTick, onMounted } from 'vue';
import { useRoute } from 'vue-router';
// 引入最新的 useGame 和 getDisplayName
import { useGame, getDisplayName } from '@/composables/useGame';
// ... 其他组件的 imports

// --- 状态管理 ---
const route = useRoute();
const {
  isLoading, gamePhase, characters, interactionHistory,
  interrogationTargets, // 使用过滤后的提问对象
  monologueProgress,
  startGame, advanceMonologue, askQuestion
} = useGame();

// ... 其他组合式函数 ...

// --- 本地组件状态 ---
const selectedCharacterId = ref<string | null>(null);
const customQuestion = ref('');
const historyLogRef = ref<HTMLElement | null>(null);

// --- 方法 ---
const handleContinue = () => {
  const entry = advanceMonologue();
  if (entry) {
    // ... 更新对话框等逻辑
  }
};

const handleAskQuestion = async () => {
  if (!customQuestion.value.trim() || !selectedCharacterId.value) return;
  await askQuestion(selectedCharacterId.value, customQuestion.value);
  customQuestion.value = '';
};

// --- 生命周期与监听 ---
onMounted(() => {
  // (修改) startGame不再需要传入角色ID
  startGame(route.params.scriptId as string, '神探李');
});

watch(interactionHistory, () => {
  nextTick(() => {
    const logEl = historyLogRef.value;
    if (logEl) {
      logEl.scrollTop = logEl.scrollHeight;
    }
  });
}, { deep: true });
</script>

<style scoped>
/* 严格按照新设计图的样式 */
:root {
  --sidebar-bg: #1a202c;
  --sidebar-section-bg: #2d3748;
  --sidebar-border-color: #4a5568;
  --text-primary: #e2e8f0;
  --text-secondary: #a0aec0;
  --accent-color: #4c51bf;
  --player-color: #38b2ac; /* 青色，用于玩家高亮 */
}

.interrogation-sidebar {
  background: var(--sidebar-bg);
  color: var(--text-primary);
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  overflow: hidden;
}

.sidebar-section {
  background: var(--sidebar-section-bg);
  border-radius: 8px;
  padding: 1rem;
  display: flex;
  flex-direction: column;
}

.section-title {
  font-size: 0.8rem;
  font-weight: 700;
  color: var(--text-secondary);
  text-transform: uppercase;
  margin: 0 0 1rem 0;
}

/* 历史记录样式 */
.history-section {
  flex-grow: 1;
  min-height: 0;
}

.history-log {
  overflow-y: auto;
  font-size: 0.875rem;
  line-height: 1.7;
  color: #cbd5e1;
  height: 100%;
  padding-right: 0.5rem;
}
.history-log::-webkit-scrollbar { width: 4px; }
.history-log::-webkit-scrollbar-thumb { background: #718096; border-radius: 2px; }

.history-placeholder { color: #718096; text-align: center; padding-top: 2rem; }
.history-entry { margin-bottom: 0.75rem; }

.history-speaker { font-weight: 600; color: #90cdf4; }
.history-speaker.player { color: var(--player-color); }
.history-content.question { color: #f6e05e; font-style: italic; }

.system-message {
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
    font-size: 0.8rem;
    padding: 0.5rem 0;
}

/* 提问区样式 */
.ask-section { flex-shrink: 0; }
.character-tabs { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; }
.tab-item {
  padding: 0.5rem 0.75rem;
  background: var(--sidebar-border-color);
  border: none;
  color: var(--text-primary);
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.875rem;
  transition: all 0.2s;
}
.tab-item:hover:not(:disabled) { background: #718096; }
.tab-item:disabled { opacity: 0.5; cursor: not-allowed; }
.tab-item.active { background: var(--accent-color); color: white; font-weight: 600; }

.custom-question-textarea {
  width: 100%;
  background: #1a202c;
  border: 1px solid var(--sidebar-border-color);
  border-radius: 6px;
  padding: 0.75rem;
  color: white;
  font-size: 0.875rem;
  resize: none;
  margin-bottom: 0.75rem;
  transition: border-color 0.2s;
}
.custom-question-textarea:focus { outline: none; border-color: var(--accent-color); }

.ask-question-button {
  width: 100%;
  padding: 0.75rem;
  background: var(--accent-color);
  border: none;
  border-radius: 6px;
  color: white;
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}
.ask-question-button:hover:not(:disabled) { background: #434190; }
.ask-question-button:disabled { opacity: 0.5; cursor: not-allowed; }
</style>
```

### **代码解释与最终效果**

1. **自动角色分配与显示 (`useGame.ts`)** :

* `startGame` 函数现在会从后端返回的角色列表中，**自动选择第一个**作为玩家的角色（您也可以修改为随机选择 `availableRoles[Math.floor(Math.random() * availableRoles.length)]`）。
* `setupCharacters` 函数会根据这个分配结果，为玩家角色添加 `(我)` 后缀，并为其他AI角色添加 `(模型名)` 后缀。这个 `displayName` 会在UI的任何地方显示。

1. **提问对象过滤 (`GalgameInterface.vue`)** :

* 我们不再直接使用 `availableCharacters` 渲染提问按钮。而是使用了 `useGame.ts` 中新增的计算属性 `interrogationTargets`。
* 这个计算属性内部已经 **自动过滤掉了玩家自己的角色** ，所以UI上天然就不会显示自己，完美实现了您的需求。

1. **日志式历史记录 (`GalgameInterface.vue`)** :

* **CSS** : `history-log` 区域的样式被重写，现在是一个可以独立滚动的区域，视觉上更像一个聊天窗口。
* **数据绑定** : 模板中的 `v-for` 现在会遍历 `interactionHistory` 数组。
* **格式化输出** : 通过 `v-if` 判断每一条记录的 `type`，我们为独白、提问、回答和系统消息设置了不同的显示格式和颜色，使其一目了然。例如，玩家的提问会用特殊的颜色高亮，让玩家能快速找到自己的发言。

现在，您的应用已经完全按照您的最新要求进行了重构。当游戏开始时，您会被自动分配一个角色，并且在提问时只能选择其他AI对手。同时，右侧的侧边栏将以一个美观且功能完善的日志形式，记录下游戏的每一个精彩瞬间。
