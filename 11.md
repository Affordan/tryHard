我们将创建一个新的组合式函数（Composable）`useGameLogic.ts`来专门处理游戏的核心逻辑，然后在主游戏界面 `GalgameInterface.vue` 中调用它。这样可以保持代码的整洁和模块化。

以下是实现您所描述功能的完整代码。

### **第1步: 创建新的游戏逻辑处理器 (`useGameLogic.ts`)**

这个文件将负责处理所有与后端API的交互，包括开始游戏、获取独白和管理游戏状态。

在您的 `src/composables/` 目录下，创建一个新文件 `useGameLogic.ts` 并添加以下代码：

**TypeScript**

```
// src/composables/useGameLogic.ts

import { ref } from 'vue'
import axios from 'axios'

// 定义独白的数据结构
export interface Monologue {
  characterId: string;
  sentences: string[];
}

// API基础URL
const API_BASE_URL = 'http://127.0.0.1:8000/api/v1/langchain-game'

export function useGameLogic() {
  // 游戏会话ID
  const sessionId = ref<string | null>(null)
  // 可供玩家选择的角色列表
  const availableCharacters = ref<string[]>([])
  // 存储所有角色独白的队列
  const monologueQueue = ref<Monologue[]>([])
  // 当前进行到哪个角色的独白
  const currentMonologueIndex = ref(0)
  // 游戏是否正在加载（例如，获取所有独白时）
  const isLoading = ref(false)
  // 存储错误信息
  const error = ref<string | null>(null)

  /**
   * 开始一个新游戏
   * @param scriptId - 要开始的剧本ID
   */
  const startGame = async (scriptId: string) => {
    isLoading.value = true
    error.value = null
    console.log(`[Frontend] 准备开始新游戏，剧本ID: ${scriptId}`)

    try {
      // 1. 调用 "Start New Game" API
      const startResponse = await axios.post(`${API_BASE_URL}/start`, {
        script_id: scriptId,
        user_id: null // 根据您的示例，这里可以为null
      })

      if (startResponse.data.success) {
        // 保存 session_id 和可用的角色列表
        sessionId.value = startResponse.data.data.session_id
        availableCharacters.value = startResponse.data.data.available_human_characters
        console.log(`[Frontend] 游戏创建成功, Session ID: ${sessionId.value}`)
        console.log(`[Frontend] 可用角色:`, availableCharacters.value)

        // 2. 预加载所有角色的独白
        await fetchAllMonologues()
      } else {
        throw new Error(startResponse.data.message || '创建游戏失败')
      }
    } catch (e: any) {
      console.error('[Frontend] 开始游戏时出错:', e)
      error.value = e.message || '无法连接到服务器'
    } finally {
      isLoading.value = false
    }
  }

  /**
   * 获取所有角色的独白并暂存
   */
  const fetchAllMonologues = async () => {
    if (!sessionId.value || availableCharacters.value.length === 0) return

    console.log('[Frontend] 开始获取所有角色的独白...')
    const tempMonologueQueue: Monologue[] = []

    // 注意：这里的角色列表是后端返回的可选角色，实际独白可能需要所有角色
    // 为了演示，我们假设就是这些角色的独白
    for (const characterId of availableCharacters.value) {
      try {
        const monologueResponse = await axios.post(
          `${API_BASE_URL}/session/${sessionId.value}/action`,
          {
            action_type: 'monologue',
            character_id: characterId
          }
        )

        if (monologueResponse.data.success) {
          tempMonologueQueue.push({
            characterId: characterId,
            sentences: monologueResponse.data.data.monologue_sentences
          })
          console.log(`[Frontend] 成功获取角色 [${characterId}] 的独白`)
        }
      } catch (e) {
        console.error(`[Frontend] 获取角色 [${characterId}] 独白失败:`, e)
      }
    }
    monologueQueue.value = tempMonologueQueue
    console.log('[Frontend] 所有独白已暂存:', monologueQueue.value)
  }

  /**
   * 推进到下一个角色的独白
   * @returns 返回下一个要进行独白的角色信息，如果没有则返回null
   */
  const advanceToNextMonologue = (): Monologue | null => {
    if (currentMonologueIndex.value < monologueQueue.value.length) {
      const nextMonologue = monologueQueue.value[currentMonologueIndex.value]
      console.log(`[Frontend] 推进幕次, 当前独白角色: ${nextMonologue.characterId}`)
      currentMonologueIndex.value++
      return nextMonologue
    }
    console.log('[Frontend] 所有角色独白已完成。')
    return null
  }

  return {
    sessionId,
    availableCharacters,
    monologueQueue,
    currentMonologueIndex,
    isLoading,
    error,
    startGame,
    advanceToNextMonologue
  }
}
```

### **第2步: 修改主游戏界面 (`GalgameInterface.vue`)**

现在，我们将在主界面组件中使用上面创建的 `useGameLogic`，并将逻辑与UI（如“继续”按钮）连接起来。

请**修改**您的 `src/components/GalgameInterface.vue` 文件：

**代码段**

```
<template>
  <div class="galgame-main-container">
    <DialogueSystem
      :is-ai-processing="isLoading" :current-dialogue="currentDialogue"
      :active-character="activeCharacter"
      :displayed-text="displayedDialogueText"
      :is-typing="isTypingActive"
      :can-continue="canContinue"
      :current-scene-index="currentMonologueIndex" :total-scenes="monologueQueue.length" :processing-progress="processingProgress"
      :show-user-interface="showUserInterface"
      :user-input="userInputText"
      @skip-typing="skipTypingEffect"
      @continue-scene="handleContinue" @submit-input="submitUserInput"
      @update-input="userInputText = $event"
    />

    </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useRoute } from 'vue-router'
// ... 您现有的 imports ...
import { useGameLogic, type Monologue } from '@/composables/useGameLogic' // 引入新的组合式函数

// ... 您现有的组合式函数调用 ...
const {
  currentDialogue,
  displayedDialogueText,
  isTypingActive,
  startTypingEffect,
  skipTypingEffect
} = useDialogueSystem()

// 新增：使用我们的核心游戏逻辑
const {
  sessionId,
  monologueQueue,
  currentMonologueIndex,
  isLoading,
  error,
  startGame,
  advanceToNextMonologue
} = useGameLogic()

const route = useRoute()

// 组件状态
const activeCharacter = ref<any>(null) // 当前说话的角色信息
const canContinue = ref(false)

// 初始化游戏
onMounted(async () => {
  const scriptId = route.params.scriptId as string
  if (scriptId) {
    await startGame(scriptId)
    // 游戏开始后，自动触发第一个角色的独白
    if (monologueQueue.value.length > 0) {
      handleContinue()
    }
  }
})

/**
 * 处理 "继续" 按钮的点击事件
 */
const handleContinue = () => {
  if (isTypingActive.value) {
    skipTypingEffect()
    return
  }

  const nextMonologue = advanceToNextMonologue()

  if (nextMonologue) {
    // 找到角色的详细数据（为了显示头像等）
    // 注意：这里需要您根据 useGameData 的实现来获取角色数据
    // 我们暂时用一个假数据代替
    activeCharacter.value = {
        characterId: nextMonologue.characterId,
        characterName: nextMonologue.characterId, // 实际应从角色数据库获取
        characterImageURL: '/placeholder.svg', // 实际应从角色数据库获取
        llmName: 'AI Model'
    }

    // 将多句话合并成一段话，用换行符连接
    const fullMonologueText = nextMonologue.sentences.join('\n\n')

    currentDialogue.text = fullMonologueText
    currentDialogue.characterId = nextMonologue.characterId
    startTypingEffect(fullMonologueText)

    // 独白进行中，可以继续
    canContinue.value = true
  } else {
    // 所有独白结束
    console.log("所有独白已结束，可以进入下一阶段，例如QNA")
    currentDialogue.text = "所有角色介绍完毕，现在可以开始自由提问了。"
    startTypingEffect(currentDialogue.text)
    // 独白结束，禁用继续按钮
    canContinue.value = false
  }
}

// ... 您现有的其他方法，如 restartScript, goToHome 等 ...

</script>

<style scoped>
/* ... 您现有的样式 ... */
</style>
```

### **代码解释和后续步骤**

1. **`useGameLogic.ts`** :

* `startGame(scriptId)`: 这个函数现在是您游戏开始的入口。它会调用后端的 `/start` 接口，获取 `session_id`，然后立即调用 `fetchAllMonologues`。
* `fetchAllMonologues()`: 这个函数会遍历角色列表，为每个角色调用后端的 `monologue` 动作接口，并将返回的独白句子（`monologue_sentences`）以 `{ characterId, sentences }` 的形式暂存在 `monologueQueue` 数组中。
* `advanceToNextMonologue()`: 这个函数是实现“幕次推进”的关键。每次调用，它会从 `monologueQueue` 中取出下一个角色的独白数据，并增加索引 `currentMonologueIndex`。

1. **`GalgameInterface.vue`** :

* **`onMounted`** : 组件加载后，会立即从路由参数中获取 `scriptId` 并调用 `startGame` 函数，从而启动整个游戏流程。
* **`handleContinue`** : 这个函数取代了您之前的 `advanceToNextScene`。当用户点击“继续”按钮时：
  * 它会调用 `advanceToNextMonologue()` 来获取下一个角色的独白。
  * 如果成功获取到，它会更新当前的角色信息（`activeCharacter`），并将独白内容传递给 `DialogueSystem` 进行显示。
  * 如果所有独白都已播放完毕 (`advanceToNextMonologue` 返回 `null`)，它会显示一条提示信息，并禁用“继续”按钮，等待您实现下一阶段（如QNA）的逻辑。
* **数据绑定** : 我已经将 `DialogueSystem` 的一些关键属性（如 `isAiProcessing`, `currentSceneIndex`, `totalScenes`）绑定到了我们新的 `useGameLogic` 的状态上，使其能够正确反映加载状态和游戏进度。

现在，当您的 `GalgameInterface` 组件加载时，它会自动开始游戏、获取所有角色的独白并暂存，然后等待您点击“继续”按钮来依次播放每个角色的开场白。
